### 一、CSS部分

#### 1、display：none与visibility：hidden的区别

他们两者都能让元素不可见。

- display：none是元素从渲染树中消失，渲染时不占据任何空间，而visibility：hidden在渲染时占据空间，只是设置内容不可见。
- display属性会造成文档重排，而visibility属性只是会让元素重绘。
- display属性是非继承属性，由于子孙结点从渲染树中消失，所以设置子孙字节属性也不可见，而visibility属性是继承属性，通过设置子孙结点的visibility属性为visible则可见。

#### 2、谈谈重排（回流）和重绘

- 当元素的尺寸、位置或某些属性发生变化时，浏览器重新渲染文档的过程叫做重排。比如改变窗口的大小，改变元素内容，改变元素位置等。
- 而重绘就是当元素样式的改变不会影响元素在文档流中的位置，比如改变颜色、背景颜色等，浏览器只是把新的样式赋予元素并进行绘制。
- 对于性能来讲，回流要比重绘的代价更高，重绘不一定造成回流，而回流一定会造成重绘。

#### 3、谈谈BFC的理解

BFC就是块级格式化上下文,是一个独立的布局环境。创建BCF的方法有浮动元素float不等于none，绝对定位，overflow不等于visible，display为inline-block等。BFC的典型应用有避免外边距重叠和解决高度塌陷。

外边距重叠就是两个相邻盒子的垂直外边距相遇时，真正的外边距等于两个发生折叠外边距的较大者。通过创建一个不同的BFC可以避免这个问题

元素脱离文档流后，无法计算准确高度，会导致高

度塌陷，BCF可以识别并包含浮动元素，即可清除浮动。

最优做法：通过CSS伪元素在容器内部元素之前和之后添加一个看不见的块级内容，并且通过clear为both清除浮动，可以同时避免以上两个问题。

#### 4、谈谈flex布局

弹性布局有两个元素，一个是弹性容器，一个是弹性元素。想要使用弹性布局，就要使用display：flex设置容器为弹性容器，容器中的内容自动成为弹性元素。

可以在弹性容器上设置的属性有：flex-direction（设置主轴方向）、flex-wrap（是否换行）、justify-content（定义项目在主轴的对齐方式，可以用来使元素居中），align-items（定义项目在交叉轴的对齐方式）

可以在弹性元素中设置order（定义项目的排序顺序）、flex-grow和flex-shrink（定义项目的放大、缩小比例）

#### 5、什么是媒体查询

媒体查询就是使用@media针对不同的媒体类型定义不同的样式。媒体查询可以针对不同的屏幕尺寸设置不同的样式。特别是需要进行响应式页面的时候需要用到。

#### 6、垂直居中的方法

- 盒子知道宽高的情况下，通过绝对定位设置4个方向为0，margin为auto。或是通过绝对定位top为50%，left为50%，通过margin负值为宽高一半来调整元素中心到页面中心。若是宽高不知，那就通过transform中的translate属性设置两个-50%缩小自身宽高的一半。还有一个需要考虑兼容性的方法就是使用flex布局，通过justify-content为center，align-items为center进行居中。

### 二、js基础

#### 1、数据类型有哪些？

- 基本数据类型有undefined、null、number、string、boolean，还有es6新出的symbol，用来创建一个独一无二的数据类型
- 引用类型有数组、对象、函数。基本数据类型是存储在栈中，而引用数据类型真正的实体存储在堆中，栈中存储的是指向这个实体堆的起始地址。

#### 2、数据类型有哪几种检测方式

- typeof。但是使用这种方式数组、对象以及null返回的都是object。
- instanceof。这种方式只能检测引用数据类型，内部实现原理是检测对象的原型链中是否包含构造函数的原型prototype对象。
- constructor。这种方式不仅能判断数据类型，实例对象还能通过constructor对象访问它的构造函数。
- Object.prototype.toString.call().还有一种方式调用Object原型上的toString方法。

#### 3、数组的检测方式有哪些？

- Array.isArray
- instanceof
- obj.__proto__ == Array.prototype
- Array.prototype.isPrototypeOf(obj)

#### 4、Null与Undefined的区别

Null与Undefined都是js的基本数据类型之一，并且他们两种数据类型都只有一个值，就是null与undefined。null表示的是一个空对象，通常用来初始化一个可能是对象的变量。undefined表示的是未定义。使用typeof判断null类型是返回的是Object。使用双等号判断null与undefined时，返回的是true。

#### 5、new操作符的实现原理

- 创建一个空对象
- 把对象的原型设置成函数的prototype对象
- 让函数的this指向该对象，然后执行构造函数，就是添加属性
- 返回这个对象

#### 6、对json数据的理解

json数据格式是前后端进行数据交换的一种常用方式。前端通过将符合json格式的数据序列化成json数据然后传送给后端，后端拿到json数据就可以解析成相应的数据类型。js提供了两个json数据与js数据结的互换方式。第一个就是Json.stringify。可以将一个符合json格式的数据转换成json格式。另一个就是Json.parse,可以将json数据转成json字符串。

#### 7、讲讲变量提升

变量提升就是无论变量在什么位置声明，就会被提升到函数首部，即使在声明之前访问变量也不会出错。这是因为js引擎在解析代码时会创建执行上下文。执行上下文有两个阶段，创建和执行。在创建阶段，主要任务就是明确this指向，创建作用域链和创建变量对象。函数形参，函数声明，变量声明都在创建变量对象时进行。通过var声明的变量初始值为undefined，具有变量提升。但是通过let、const声明的变量没有关联任何值，所以没有变量提升，在变量声明之前访问变量会出现引用错误的提示。

#### 8、谈谈作用域与作用域链。

作用域就是规定了在哪些范围内查找变量。作用域有词法作用域和动态作用域。词法作用域是指函数的作用域在函数定义时就已经决定了，而动态作用域是函数在调用时才决定。js使用的是第一种，词法作用域。在函数创建的时候，会有一个内部对象叫scope，保存着其父级的变量对象，在函数被激活时，函数的活动对象就被加入到scope的最前端，当查找变量时，先从自身的活动变量中找，如果没有，就从父级的变量对象中找，一级一级查找下去就构成了作用域链。

#### 9、聊聊this的指向

this的指向是在函数被调用时决定的。如果函数是使用new操作符调用的，this就指向创建的对象；如果函数是通过call，apply，bind函数调用，this就指向其指定的对象；如果函数是通过上下文对象调用，this就指向这个对象；其余的调用方式就是指向全局对象window。有一个注意点就是箭头函数的this，箭头函数是没有自己的 this的，箭头函数的this继承包含它的外部函数中的this。

#### 10、谈谈闭包

闭包是指有权访问另一个函数作用域变量的函数。闭包常见的创建方式是在一个函数内部创建另一个函数。闭包的第一个作用是在外部函数中访问内部函数的变量，所以可以用来创建私有变量。另一个作用是使执行完的函数上下文中的变量保存在内存中，不会被垃圾回收机制回收。

#### 11、原型与原型链

每个构造函数中都有一个prototype属性，这个属性值是一个对象。这个对象中包含着这个构造函数所有实例共享的属性和方法。由这个构造函数创建出来的实例都有一个指针指向这个对象，这个指针就是对象的原型。浏览器用—proto—表示。在es5之后，就可以通过Object.getPrototypeOf这个方法获取对象的原型。

当访问一个对象的属性时，如果对象内部不存在这个属性，就会从对象的原型中查找，而原型对象又有自己的原型，一直查找下去就形成了原型链，原型链的最后一般都查找到Object的原型，再下一层就是null了。

#### 12、常见的dom操作方法

- dom结点的获取：getElementById，getElementByTagName，getElementByClassName，querySelectorAll
- dom结点的创建：createElement，innerHTML
- dom结点的删除：removeChild
- dom结点的修改：appendChild，insertBefore

#### 13、什么是垃圾回收

垃圾回收有两种机制，一种是清除标记，还有一种是引用计数。清除标记就是找到环境变量中已经无法被访问的变量进行回收。尽量不用全局变量就是因为全局变量的自动回收很难判断，当数据不再有用的时候，就要将变量赋值为null，以便解除引用。引用计数就是当变量被引用一次，计数就加一，当数据引用计数为0的时候，就代表这个变量没有被引用了，可以进行回收了。

#### 14、什么是异步

js任务有两种，同步和异步。因为js是单线程，在同一时间只能干一件事，但是有一些任务，比如计时器，服务器请求一些响应时间比较长的操作，为了避免浏览器失去响应，就要用到异步操作。在js引擎解析代码的时候，遇到同步任务就放入主线程中按照顺序执行，遇到异步操作的时候，就注册回调函数放入消息队列，当主线程执行完同步任务空闲的时候，就会去消息队列读取相应的函数放入主线程执行，这个过程一直循环，就是我们常说的event loop事件循环机制。

#### 15、客户端存储的方式有哪些。

客户端存储的方式有三种，cookie，sessionStorage，localStorage。就存储时效来说，cookie可以设置失效时间，在失效时间过后失效，sessionStorage在浏览器窗口关闭之后失效。localStorage是永久存储，除非手动删除才会失效。就存储大小来说，cookie会在客户端和服务器请求中来回传送，数据大小一般不超过4k，而两种web Storage的存储数据比较大，可以达到5m以上。

#### 16、了解过跨域吗？

跨域是因为浏览器使用了同源策源，同源就是指协议，域名，端口号都要相同，如果有一处不一致就是跨域了。跨域的解决方法有很多种，比如jsonp，它的原理就是利用<script><img>等不受同源策略限制的标签进行请求。但是jsonp只能进行get请求，局限比较大。比较常用的CORS跨域资源共享。对于简单请求，直接发出CORS请求，就是在头部信息中添加origin字段。对于非简单请求，会在通信之前，增加一次http请求，看看网页所在域名是不是在服务器的准许名单之内。还有一种比较常用的就是反向代理了，它的原理是通过服务器是没有同源策略，然后配置一个和客户端同域名的代理服务器去向真实的服务器发送请求。

#### 17、说说防抖和节流

防抖就是在事件触发的一段时间内执行回调，如果在这段时间内又触发了一次，就重新计时。节流就是在一段时间内只执行一次回调，如果在这段时间内触发了多次，就只有第一次有效。

#### 18、箭头函数

箭头函数比普通的函数的写法简洁，就是小括号写上参数，然后箭头指向大括号包含的函数体。箭头函数没有自己的this，它的this是包含箭头函数的外部函数中的this。箭头函数也没有arguments参数列表。它也没有new.target，所以不能作为构造函数。箭头函数比较适合替代那些匿名函数。

#### 19、谈谈浏览器对象模型（BOM）

浏览器对象模型的核心是window，window不仅是es中的全局对象，也是js访问浏览器窗口的接口。location对象不仅保存着文档中的相关信息，也保存着URL解析后能通过属性访问的信息，比如location.hash得到url的hash值，location.port得到端口等。navigator对象通常就是用来判断浏览器的类型，通过navigator的userAgent判断。还有一个比较有用的对象就是history，保存着窗口的历史记录，可以通过go，back，forward等方法进行前进、回退。还有一个不太常用的screen对象。获取浏览器的可用宽度，可用高度等。

### 20、什么是深拷贝、什么浅拷贝

浅拷贝就是只拷贝第一层的原始类型值和第一层的引用类型地址。常见的方式有对象的Object.assign()，数据的slice和concat还有ES6的扩展运算符都是浅拷贝

深拷贝指的是拷贝所有的属性值以及属性地址指向的值的内存空间

### 三、计算机网络

#### 1、什么是3次握手

三次握手是发生TCP连接的时候，客户端和服务器一共需要发送三个数据包来确保对象的接受能力和发送能力是否正常。第一次握手是客户端发送一个SYN报文，并指明自己的初始化序号。第二次握手是服务器接受到客户端的报文之后，也发送一个自己的SYN与自己的初始化序号，确认号ACK是收到SYN报文的序列号+1的报文。第三次握手是客户端收到报文后，发送一个确认号ACK是序列号+1的报文。经过这三次握手，TCP连接就建立了。

#### 2、浏览器输入url按下回车发生了什么

首先会进行DNS域名解析，就是将网址转换成IP地址的过程。然后进行TCP连接，连接过程就是俗称的三次握手。连接成功后就开始发送http请求，然后服务器处理请求并返回报文接着浏览器解析渲染页面，这里涉及了一个回流和重绘的概念。回流就是浏览器根据渲染树中元素的尺寸，位置等进行构建。重绘就是绘制元素的样式，比如颜色，背景颜色什么的。最后断开连接。断开连接就是我们所说的4次挥手。第一次挥手是客户端向服务器发送一个FIN报文并指定一个初始序列号，第二次挥手是服务器收到报文，把序列号+1作为确认号ACK的值发送回去，然后客户端到服务器的连接就断开了，如果服务器也想断开和客户端的连接，就进行和客户端刚刚的操作，客户端进行应答，一共就进行了4次数据报传送。

#### 3、get与post的区别

get和post都是http请求的方式。get请求一般是获取数据，请求参数会出现在url中，并且数据不能太长。post请求一般是向服务器发送数据，请求数据会放在请求包的包体中，数据大小没有限制。相对来说比较安全。get请求在回退时是无害的，但是post请求在回退时需要重新进行请求。

#### 4、常见的状态码

以2开头，就是代表请求被正常处理了，比如200表示ok，204表示正常处理但是没有返回内容

以3开头表示重定向。比如301是永久重定向，302是临时重定向

以4开发一般是客户端发生错误。比如403表示访问被服务器拒绝，404是找不到请求资源

以5开头就是服务器发生错误。比如502是没有响应，504是响应超时了

### 四、模块化

#### 1、谈谈对模块化的理解

模块化就是为了解决命名冲突和文件依赖。commonJS规范是同步加载模块机制，并且可进行多次加载，但是只会在第一次加载时运行，然后结果就被缓存了。使用require导入，module.exports导出。AMD是异步模块加载机制，AMD规范和CMD规范很相似，不同的是AMD是前置依赖，就是在定义模块的时候就要声明需要依赖的模块，而CMD是就近依赖，只有用到某些模块的时候再去require。es6模块规范是按需加载，也就是编译时才加载。使用import导入，export或是export default导出。