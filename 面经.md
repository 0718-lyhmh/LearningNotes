### 一、CSS部分

#### 1、display：none与visibility：hidden的区别

他们两者都能让元素不可见。

- display：none是元素从渲染树中消失，渲染时不占据任何空间，而visibility：hidden在渲染时占据空间，只是设置内容不可见。
- display属性会造成文档重排，而visibility属性只是会让元素重绘。
- display属性是非继承属性，由于子孙结点从渲染树中消失，所以设置子孙字节属性也不可见，而visibility属性是继承属性，通过设置子孙结点的visibility属性为visible则可见。

#### 2、谈谈重排（回流）和重绘

- 当元素的尺寸、位置或某些属性发生变化时，浏览器重新渲染文档的过程叫做重排。比如改变窗口的大小，改变元素内容，改变元素位置等。
- 而重绘就是当元素样式的改变不会影响元素在文档流中的位置，比如改变颜色、背景颜色等，浏览器只是把新的样式赋予元素并进行绘制。
- 对于性能来讲，回流要比重绘的代价更高，重绘不一定造成回流，而回流一定会造成重绘。

#### 3、谈谈BFC的理解

BFC就是块级格式化上下文,是一个独立的布局环境。创建BCF的方法有浮动元素float不等于none，绝对定位，overflow不等于visible，display为inline-block等。BFC的典型应用有避免外边距重叠和解决高度塌陷。

外边距重叠就是两个相邻盒子的外边距相遇时，真正的外边距等于两个发生折叠外边距的较大者。通过创建一个不同的BFC可以避免这个问题

元素脱离文档流后，无法计算准确高度，会导致高度塌陷，BCF可以识别并包含浮动元素，即可清除浮动。

最优做法：通过CSS伪元素在容器内部元素之前和之后添加一个看不见的块级内容，并且通过clear为both清除浮动，可以同时避免以上两个问题。

#### 4、谈谈flex布局

弹性布局有两个元素，一个是弹性容器，一个是弹性元素。想要使用弹性布局，就要使用display：flex设置容器为弹性容器，容器中的内容自动成为弹性元素。

可以在弹性容器上设置的属性有：flex-direction（设置主轴方向）、flex-wrap（是否换行）、justify-content（定义项目在主轴的对齐方式，可以用来使元素居中），align-items（定义项目在交叉轴的对齐方式）

可以在弹性元素中设置order（定义项目的排序顺序）、flex-grow和flex-shrink（定义项目的放大、缩小比例）

#### 5、什么是媒体查询

媒体查询就是使用@media针对不同的媒体类型定义不同的样式。媒体查询可以针对不同的屏幕尺寸设置不同的样式。特别是需要进行响应式页面的时候需要用到。

#### 6、垂直居中的方法

- 盒子知道宽高的情况下，通过绝对定位设置4个方向为0，margin为auto。或是通过绝对定位top为50%，left为50%，通过margin负值为宽高一般来调整元素中心到页面中心。若是宽高不知，那就通过transform中的translate属性设置两个-50%缩小自身宽高的一半。还有一个需要考虑兼容性的方法就是使用flex布局，通过justify-content为center，align-items为center进行居中。

### 二、js基础

#### 1、数据类型有哪些？

- 基本数据类型有undefined、null、number、string、boolean，还有es6新出的symbol，用来创建一个独一无二的数据类型
- 引用类型有数组、对象、函数。基本数据类型是存储在栈中，而引用数据类型真正的实体存储在堆中，栈中存储的是指向这个实体堆的起始地址。

#### 2、数据类型有哪几种检测方式

- typeof。但是使用这种方式数组、对象以及null返回的都是object。
- instanceof。这种方式只能检测引用数据类型，内部实现原理是检测对象的原型链中是否包含构造函数的原型prototype对象。
- constructor。这种方式不仅能判断数据类型，实例对象还能通过constructor对象访问它的构造函数。
- Object.prototype.toString.call().还有一种方式调用Object原型上的toString方法。

#### 3、数组的检测方式有哪些？

- Array.isArray
- instanceof
- obj.__proto__ == Array.prototype
- Array.prototype.isPrototypeOf(obj)

#### 4、Null与Undefined的区别

Null与Undefined都是js的基本数据类型之一，并且他们两种数据类型都只有一个值，就是null与undefined。null表示的是一个空对象，通常用来初始化一个可能是对象的变量。undefined表示的是undefined表示的是未定义。使用typeof判断null类型是返回的是Object。使用双等号判断null与undefined时，返回的是true。

#### 5、new操作符的实现原理

- 创建一个空对象
- 把对象的原型设置成函数的prototype对象
- 让函数的this指向该对象，然后执行构造函数，就是添加属性
- 判断返回值的类型，如果是值类型，就返回该对象，如果是引用类型，就返回这个引用类型的对象。

#### 6、对象json数据的理解

json数据格式是前后端进行数据交换的一种常用方式。前端通过将符合json格式的数据序列化成json数据然后传送给后端，后端拿到json数据就可以解析成相应的数据类型。js提供了两个json数据与js数据结的互换方式。第一个就是Json.stringify。可以将一个符合json格式的数据转换成json格式。另一个就是Json.parse,可以将json数据转成json字符串。

#### 7、讲讲变量提升

变量提升就是无论变量在什么位置声明，就会被提升到函数首部，即使在声明之前访问变量也不会出错。这是因为js引擎在解析代码时会创建执行上下文。执行上下文有两个阶段，创建和执行。在创建阶段，主要任务就是明确this指向，创建作用域链和创建变量对象。函数形参，函数声明，变量声明都在创建变量对象时进行。通过var声明的变量初始值为undefined，具有变量提升。但是通过let、const声明的变量没有关联任何值，所以没有变量提升，在变量声明之前访问变量会出现引用错误的提示。

#### 8、谈谈作用域与作用域链。

作用域就是规定了在哪些范围内查找变量。作用域有词法作用域和动态作用域。词法作用域是指函数的作用域在函数定义时就已经决定了，而动态作用域是函数在调用时才决定。js使用的是第一种，词法作用域。在函数创建的时候，会有一个内部对象叫scope，保存着其父级的变量对象，在函数被激活时，函数的活动对象就被加入到scope的最前端，当查找变量时，先从自身的活动变量中找，如果没有，就从父级的变量对象中找，一级一级查找下去就构成了作用域链。

#### 9、聊聊this的指向

this的指向是在函数被调用时决定的。如果函数是使用new操作符调用的，this就指向创建的对象；如果函数是通过call，apply，bind函数调用，this就指向其指定的对象；如果函数是通过上下文对象调用，this就指向这个对象；其余的调用方式就是指向全局对象window。有一个注意点就是箭头函数的this，箭头函数是没有自己的 this的，箭头函数的this继承包含它的外部函数中的this。

#### 10、谈谈闭包

闭包是指有权访问另一个函数作用域变量的函数。闭包常见的创建方式是在一个函数内部创建另一个函数。闭包的第一个作用是在外部函数中访问内部函数的变量，所以可以用来创建私有变量。另一个作用是使执行完的函数上下文中的变量保存在内存中，不会被垃圾回收机制回收。

#### 12、常见的dom操作方法

- dom结点的获取：getElementById，getElementByTagName，getElementByClassName，querySelectorAll
- dom结点的创建：createElement，innerHTML
- dom结点的删除：removeChild
- dom结点的修改：appendChild，insertBefore